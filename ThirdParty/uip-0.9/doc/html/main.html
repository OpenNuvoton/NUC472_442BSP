<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uIP 0.9: The uIP TCP/IP stack</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindexHL" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>The uIP TCP/IP stack </h1>
<p>
<dl compact><dt><b>Author:</b></dt><dd>Adam Dunkels &lt;<a href="mailto:adam@dunkels.com">adam@dunkels.com</a>&gt;</dd></dl>
The uIP TCP/IP stack is intended to make it possible to communicate using the TCP/IP protocol suite even on small 8-bit micro-controllers. Despite being small and simple, uIP do not require their peers to have complex, full-size stacks, but can communicate with peers running a similarly light-weight stack. The code size is on the order of a few kilobytes and RAM usage can be configured to be as low as a few hundred bytes.<h2><a name="uIPIntroduction"></a>
uIP introduction</h2>
With the success of the Internet, the TCP/IP protocol suite has become a global standard for communication. TCP/IP is the underlying protocol used for web page transfers, e-mail transmissions, file transfers, and peer-to-peer networking over the Internet. For embedded systems, being able to run native TCP/IP makes it possible to connect the system directly to an intranet or even the global Internet. Embedded devices with full TCP/IP support will be first-class network citizens, thus being able to fully communicate with other hosts in the network.<p>
Traditional TCP/IP implementations have required far too much resources both in terms of code size and memory usage to be useful in small 8 or 16-bit systems. Code size of a few hundred kilobytes and RAM requirements of several hundreds of kilobytes have made it impossible to fit the full TCP/IP stack into systems with a few tens of kilobytes of RAM and room for less than 100 kilobytes of code.<p>
The uIP implementation is designed to have only the absolute minimal set of features needed for a full TCP/IP stack. It can only handle a single network interface and contains only a rudimentary UDP implementation, but focuses on the IP, ICMP and TCP protocols. uIP is written in the C programming language.<p>
Many other TCP/IP implementations for small systems assume that the embedded device always will communicate with a full-scale TCP/IP implementation running on a workstation-class machine. Under this assumption, it is possible to remove certain TCP/IP mechanisms that are very rarely used in such situations. Many of those mechanisms are essential, however, if the embedded device is to communicate with another equally limited device, e.g., when running distributed peer-to-peer services and protocols. uIP is designed to be RFC compliant in order to let the embedded devices to act as first-class network citizens. The uIP TCP/IP implementation that is not tailored for any specific application.<h2><a name="tcpip"></a>
TCP/IP communication</h2>
The full TCP/IP suite consists of numerous protocols, ranging from low level protocols such as ARP which translates IP addresses to MAC addresses, to application level protocols such as SMTP that is used to transfer e-mail. The uIP is mostly concerned with the TCP and IP protocols and upper layer protocols will be referred to as "the application". Lower layer protocols are often implemented in hardware or firmware and will be referred to as "the network device" that are controlled by the network device driver.<p>
TCP provides a reliable byte stream to the upper layer protocols. It breaks the byte stream into appropriately sized segments and each segment is sent in its own IP packet. The IP packets are sent out on the network by the network device driver. If the destination is not on the physically connected network, the IP packet is forwarded onto another network by a router that is situated between the two networks. If the maximum packet size of the other network is smaller than the size of the IP packet, the packet is fragmented into smaller packets by the router. If possible, the size of the TCP segments are chosen so that fragmentation is minimized. The final recipient of the packet will have to reassemble any fragmented IP packets before they can be passed to higher layers.<p>
The formal requirements for the protocols in the TCP/IP stack is specified in a number of RFC documents published by the Internet Engineering Task Force, IETF. Each of the protocols in the stack is defined in one more RFC documents and RFC1122 collects all requirements and updates the previous RFCs.<p>
The RFC1122 requirements can be divided into two categories; those that deal with the host to host communication and those that deal with communication between the application and the networking stack. An example of the first kind is "A TCP MUST be able to receive a TCP option in any segment" and an example of the second kind is "There MUST be a mechanism for reporting soft TCP error conditions to the application." A TCP/IP implementation that violates requirements of the first kind may not be able to communicate with other TCP/IP implementations and may even lead to network failures. Violation of the second kind of requirements will only affect the communication within the system and will not affect host-to-host communication.<p>
In uIP, all RFC requirements that affect host-to-host communication are implemented. However, in order to reduce code size, we have removed certain mechanisms in the interface between the application and the stack, such as the soft error reporting mechanism and dynamically configurable type-of-service bits for TCP connections. Since there are only very few applications that make use of those features they can be removed without loss of generality.<h2><a name="memory"></a>
Memory management</h2>
In the architectures for which uIP is intended, RAM is the most scarce resource. With only a few kilobytes of RAM available for the TCP/IP stack to use, mechanisms used in traditional TCP/IP cannot be directly applied.<p>
The uIP stack does not use explicit dynamic memory allocation. Instead, it uses a single global buffer for holding packets and has a fixed table for holding connection state. The global packet buffer is large enough to contain one packet of maximum size. When a packet arrives from the network, the device driver places it in the global buffer and calls the TCP/IP stack. If the packet contains data, the TCP/IP stack will notify the corresponding application. Because the data in the buffer will be overwritten by the next incoming packet, the application will either have to act immediately on the data or copy the data into a secondary buffer for later processing. The packet buffer will not be overwritten by new packets before the application has processed the data. Packets that arrive when the application is processing the data must be queued, either by the network device or by the device driver. Most single-chip Ethernet controllers have on-chip buffers that are large enough to contain at least 4 maximum sized Ethernet frames. Devices that are handled by the processor, such as RS-232 ports, can copy incoming bytes to a separate buffer during application processing. If the buffers are full, the incoming packet is dropped. This will cause performance degradation, but only when multiple connections are running in parallel. This is because uIP advertises a very small receiver window, which means that only a single TCP segment will be in the network per connection.<p>
In uIP, the same global packet buffer that is used for incoming packets is also used for the TCP/IP headers of outgoing data. If the application sends dynamic data, it may use the parts of the global packet buffer that are not used for headers as a temporary storage buffer. To send the data, the application passes a pointer to the data as well as the length of the data to the stack. The TCP/IP headers are written into the global buffer and once the headers have been produced, the device driver sends the headers and the application data out on the network. The data is not queued for retransmissions. Instead, the application will have to reproduce the data if a retransmission is necessary.<p>
The total amount of memory usage for uIP depends heavily on the applications of the particular device in which the implementations are to be run. The memory configuration determines both the amount of traffic the system should be able to handle and the maximum amount of simultaneous connections. A device that will be sending large e-mails while at the same time running a web server with highly dynamic web pages and multiple simultaneous clients, will require more RAM than a simple Telnet server. It is possible to run the uIP implementation with as little as 200 bytes of RAM, but such a configuration will provide extremely low throughput and will only allow a small number of simultaneous connections.<h2><a name="api"></a>
Application program interface (API)</h2>
The Application Program Interface (API) defines the way the application program interacts with the TCP/IP stack. The most commonly used API for TCP/IP is the BSD socket API which is used in most Unix systems and has heavily influenced the Microsoft Windows WinSock API. Because the socket API uses stop-and-wait semantics, it requires support from an underlying multitasking operating system. Since the overhead of task management, context switching and allocation of stack space for the tasks might be too high in the intended uIP target architectures, the BSD socket interface is not suitable for our purposes.<p>
Instead, uIP uses an event driven interface where the application is invoked in response to certain events. An application running on top of uIP is implemented as a C function that is called by uIP in response to certain events. uIP calls the application when data is received, when data has been successfully delivered to the other end of the connection, when a new connection has been set up, or when data has to be retransmitted. The application is also periodically polled for new data. The application program provides only one callback function; it is up to the application to deal with mapping different network services to different ports and connections. Because the application is able to act on incoming data and connection requests as soon as the TCP/IP stack receives the packet, low response times can be achieved even in low-end systems.<p>
uIP is different from other TCP/IP stacks in that it requires help from the application when doing retransmissions. Other TCP/IP stacks buffer the transmitted data in memory until the data is known to be successfully delivered to the remote end of the connection. If the data needs to be retransmitted, the stack takes care of the retransmission without notifying the application. With this approach, the data has to be buffered in memory while waiting for an acknowledgment even if the application might be able to quickly regenerate the data if a retransmission has to be made.<p>
In order to reduce memory usage, uIP utilizes the fact that the application may be able to regenerate sent data and lets the application take part in retransmissions. uIP does not keep track of packet contents after they have been sent by the device driver, and uIP requires that the application takes an active part in performing the retransmission. When uIP decides that a segment should be retransmitted, it calls the application with a flag set indicating that a retransmission is required. The application checks the retransmission flag and produces the same data that was previously sent. From the application's standpoint, performing a retransmission is not different from how the data originally was sent. Therefore the application can be written in such a way that the same code is used both for sending data and retransmitting data. Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.<h3><a name="appevents"></a>
Application events</h3>
The application must be implemented as a C function, <a class="el" href="a00094.html#a0">UIP_APPCALL()</a>, that uIP calls whenever an event occurs. Each event has a corresponding test function that is used to distinguish between different events. The functions are implemented as C macros that will evaluate to either zero or non-zero. Note that certain events can happen in conjunction with each other (i.e., new data can arrive at the same time as data is acknowledged).<h3><a name="connstate"></a>
The connection pointer</h3>
When the application is called by uIP, the global variable <a class="el" href="a00037.html">uip_conn</a> is set to point to the <a class="el" href="a00037.html">uip_conn</a> structure for the connection that currently is handled, and is called the "current connection". The fields in the <a class="el" href="a00037.html">uip_conn</a> structure for the current connection can be used, e.g., to distinguish between different services, or to check to which IP address the connection is connected. One typical use would be to inspect the uip_conn-&gt;lport (the local TCP port number) to decide which service the connection should provide. For instance, an application might decide to act as an HTTP server if the value of uip_conn-&gt;lport is equal to 80 and act as a TELNET server if the value is 23.<h3><a name="recvdata"></a>
Receiving data</h3>
If the uIP test function <a class="el" href="a00080.html#a13">uip_newdata()</a> is non-zero, the remote host of the connection has sent new data. The uip_appdata pointer point to the actual data. The size of the data is obtained through the uIP function <a class="el" href="a00080.html#a6">uip_datalen()</a>. The data is not buffered by uIP, but will be overwritten after the application function returns, and the application will therefor have to either act directly on the incoming data, or by itself copy the incoming data into a buffer for later processing.<h3><a name="senddata"></a>
Sending data</h3>
When sending data, uIP adjusts the length of the data sent by the application according to the available buffer space and the current TCP window advertised by the receiver. The amount of buffer space is dictated by the memory configuration. It is therefore possible that all data sent from the application does not arrive at the receiver, and the application may use the <a class="el" href="a00080.html#a22">uip_mss()</a> function to see how much data that actually will be sent by the stack.<p>
The application sends data by using the uIP function <a class="el" href="a00080.html#a5">uip_send()</a>. The <a class="el" href="a00080.html#a5">uip_send()</a> function takes two arguments; a pointer to the data to be sent and the length of the data. If the application needs RAM space for producing the actual data that should be sent, the packet buffer (pointed to by the uip_appdata pointer) can be used for this purpose.<p>
The application can send only one chunk of data at a time on a connection and it is not possible to call <a class="el" href="a00080.html#a5">uip_send()</a> more than once per application invocation; only the data from the last call will be sent.<h3><a name="rexmitdata"></a>
Retransmitting data</h3>
Retransmissions are driven by the periodic TCP timer. Every time the periodic timer is invoked, the retransmission timer for each connection is decremented. If the timer reaches zero, a retransmission should be made. As uIP does not keep track of packet contents after they have been sent by the device driver, uIP requires that the application takes an active part in performing the retransmission. When uIP decides that a segment should be retransmitted, the application function is called with the <a class="el" href="a00080.html#a19">uip_rexmit()</a> flag set, indicating that a retransmission is required.<p>
The application must check the <a class="el" href="a00080.html#a19">uip_rexmit()</a> flag and produce the same data that was previously sent. From the application's standpoint, performing a retransmission is not different from how the data originally was sent. Therefor, the application can be written in such a way that the same code is used both for sending data and retransmitting data. Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.<h3><a name="closing"></a>
Closing connections</h3>
The application closes the current connection by calling the <a class="el" href="a00080.html#a8">uip_close()</a> during an application call. This will cause the connection to be cleanly closed. In order to indicate a fatal error, the application might want to abort the connection and does so by calling the <a class="el" href="a00080.html#a9">uip_abort()</a> function.<p>
If the connection has been closed by the remote end, the test function <a class="el" href="a00080.html#a16">uip_closed()</a> is true. The application may then do any necessary cleanups.<h3><a name="errors"></a>
Reporting errors</h3>
There are two fatal errors that can happen to a connection, either that the connection was aborted by the remote host, or that the connection retransmitted the last data too many times and has been aborted. uIP reports this by calling the application function. The application can use the two test functions <a class="el" href="a00080.html#a17">uip_aborted()</a> and <a class="el" href="a00080.html#a18">uip_timedout()</a> to test for those error conditions.<h3><a name="polling"></a>
Polling</h3>
When a connection is idle, uIP polls the application every time the periodic timer fires. The application uses the test function <a class="el" href="a00080.html#a20">uip_poll()</a> to check if it is being polled by uIP.<p>
The polling event has two purposes. The first is to let the application periodically know that a connection is idle, which allows the application to close connections that have been idle for too long. The other purpose is to let the application send new data that has been produced. The application can only send data when invoked by uIP, and therefore the poll event is the only way to send data on an otherwise idle connection.<h3><a name="listen"></a>
Listening ports</h3>
uIP maintains a list of listening TCP ports. A new port is opened for listening with the <a class="el" href="a00080.html#a0">uip_listen()</a> function. When a connection request arrives on a listening port, uIP creates a new connection and calls the application function. The test function <a class="el" href="a00080.html#a15">uip_connected()</a> is true if the application was invoked because a new connection was created.<p>
The application can check the lport field in the <a class="el" href="a00037.html">uip_conn</a> structure to check to which port the new connection was connected.<h3><a name="connect"></a>
Opening connections</h3>
New connections can be opened from within uIP by the function <a class="el" href="a00080.html#a2">uip_connect()</a>. This function allocates a new connection and sets a flag in the connection state which will open a TCP connection to the specified IP address and port the next time the connection is polled by uIP. The <a class="el" href="a00080.html#a2">uip_connect()</a> function returns a pointer to the <a class="el" href="a00037.html">uip_conn</a> structure for the new connection. If there are no free connection slots, the function returns NULL.<p>
The function <a class="el" href="a00081.html#a1">uip_ipaddr()</a> may be used to pack an IP address into the two element 16-bit array used by uIP to represent IP addresses.<p>
Two examples of usage are shown below. The first example shows how to open a connection to TCP port 8080 of the remote end of the current connection. If there are not enough TCP connection slots to allow a new connection to be opened, the <a class="el" href="a00080.html#a2">uip_connect()</a> function returns NULL and the current connection is aborted by <a class="el" href="a00080.html#a9">uip_abort()</a>.<p>
<div class="fragment"><pre><span class="keywordtype">void</span> connect_example1_app(<span class="keywordtype">void</span>) {
   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a2">uip_connect</a>(<a class="code" href="a00037.html">uip_conn</a>-&gt;ripaddr, <a class="code" href="a00081.html#a2">HTONS</a>(8080)) == NULL) {
      <a class="code" href="a00080.html#a9">uip_abort</a>();
   }
}   
</pre></div><p>
The second example shows how to open a new connection to a specific IP address. No error checks are made in this example.<p>
<div class="fragment"><pre><span class="keywordtype">void</span> connect_example2(<span class="keywordtype">void</span>) {
   <a class="code" href="a00086.html#a1">u16_t</a> ipaddr[2];

   <a class="code" href="a00081.html#a1">uip_ipaddr</a>(ipaddr, 192,168,0,1);
   <a class="code" href="a00080.html#a2">uip_connect</a>(ipaddr, <a class="code" href="a00081.html#a2">HTONS</a>(8080));
}
</pre></div><h2><a name="drivers"></a>
uIP device drivers</h2>
From the network device driver's standpoint, uIP consists of two C functions: <a class="el" href="a00079.html#a1">uip_input()</a> and <a class="el" href="a00079.html#a2">uip_periodic()</a>. The <a class="el" href="a00079.html#a1">uip_input()</a> function should be called by the device driver when an IP packet has been received and put into the uip_buf packet buffer. The <a class="el" href="a00079.html#a1">uip_input()</a> function will process the packet, and when it returns an outbound packet may have been placed in the same uip_buf packet buffer (indicated by the uip_len variable being non-zero). The device driver should then send out this packet onto the network.<p>
The <a class="el" href="a00079.html#a2">uip_periodic()</a> function should be invoked periodically once per connection by the device driver, typically one per second. This function is used by uIP to drive protocol timers and retransmissions, and when it returns it may have placed an outbound packet in the uip_buf buffer.<h2><a name="arch"></a>
Architecture specific functions</h2>
uIP requires a few functions to be implemented specifically for the architecture on which uIP is intended to run. These functions should be hand-tuned for the particular architecture, but generic C implementations are given as part of the uIP distribution.<h3><a name="checksums"></a>
Checksum calculation</h3>
The TCP and IP protocols implement a checksum that covers the data and header portions of the TCP and IP packets. Since the calculation of this checksum is made over all bytes in every packet being sent and received it is important that the function that calculates the checksum is efficient. Most often, this means that the checksum calculation must be fine-tuned for the particular architecture on which the uIP stack runs.<p>
Because of this, uIP does not implement a generic checksum function, but leaves this to the architecture specific files which must implement the two functions <a class="el" href="a00082.html#a3">uip_ipchksum()</a> and <a class="el" href="a00082.html#a4">uip_tcpchksum()</a>. The checksum calculations in those functions can be written in highly optimized assembler rather than generic C code.<p>
An example C implementation of the checksum function is provided in the uIP distribution.<h3><a name="longarith"></a>
32-bit arithmetic</h3>
The TCP protocol uses 32-bit sequence numbers, and a TCP implementation will have to do a number of 32-bit additions as part of the normal protocol processing. Since 32-bit arithmetic is not natively available on many of the platforms for which uIP is intended, uIP leaves the 32-bit additions to be implemented by the architecture specific module and does not make use of any 32-bit arithmetic in the main code base.<p>
The architecture specific code must implement a function <a class="el" href="a00082.html#a1">uip_add32()</a> which does a 32-bit addition and stores the result in a global variable uip_acc32.<h2><a name="examples"></a>
Examples</h2>
This section presents a number of very simple uIP applications. The uIP code distribution contains several more complex applications.<h3><a name="example1"></a>
A very simple application</h3>
This first example shows a very simple application. The application listens for incoming connections on port 1234. When a connection has been established, the application replies to all data sent to it by saying "ok"<p>
The implementation of this application is shown below. The application is initialized with the function called example1_init() and the uIP callback function is called example1_app(). For this application, the configuration variable UIP_APPCALL should be defined to be example1_app().<p>
<div class="fragment"><pre><span class="keywordtype">void</span> example1_init(<span class="keywordtype">void</span>) {
   <a class="code" href="a00080.html#a25">uip_listen</a>(<a class="code" href="a00081.html#a2">HTONS</a>(1234));
}

<span class="keywordtype">void</span> example1_app(<span class="keywordtype">void</span>) {
   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a13">uip_newdata</a>() || <a class="code" href="a00080.html#a19">uip_rexmit</a>()) {
      <a class="code" href="a00080.html#a5">uip_send</a>(<span class="stringliteral">"ok\n"</span>, 3);
   }
}
</pre></div><p>
The initialization function calls the uIP function <a class="el" href="a00080.html#a0">uip_listen()</a> to register a listening port. The actual application function example1_app() uses the test functions <a class="el" href="a00080.html#a13">uip_newdata()</a> and <a class="el" href="a00080.html#a19">uip_rexmit()</a> to determine why it was called. If the application was called because the remote end has sent it data, it responds with an "ok". If the application function was called because data was lost in the network and has to be retransmitted, it also sends an "ok". Note that this example actually shows a complete uIP application. It is not required for an application to deal with all types of events such as <a class="el" href="a00080.html#a15">uip_connected()</a> or <a class="el" href="a00080.html#a18">uip_timedout()</a>.<h3><a name="example2"></a>
A more advanced application</h3>
This second example is slightly more advanced than the previous one, and shows how the application state field in the <a class="el" href="a00037.html">uip_conn</a> structure is used.<p>
This application is similar to the first application in that it listens to a port for incoming connections and responds to data sent to it with a single "ok". The big difference is that this application prints out a welcoming "Welcome!" message when the connection has been established.<p>
This seemingly small change of operation makes a big difference in how the application is implemented. The reason for the increase in complexity is that if data should be lost in the network, the application must know what data to retransmit. If the "Welcome!" message was lost, the application must retransmit the welcome and if one of the "ok" messages is lost, the application must send a new "ok".<p>
The application knows that as long as the "Welcome!" message has not been acknowledged by the remote host, it might have been dropped in the network. But once the remote host has sent an acknowledgment back, the application can be sure that the welcome has been received and knows that any lost data must be an "ok" message. Thus the application can be in either of two states: either in the WELCOME-SENT state where the "Welcome!" has been sent but not acknowledged, or in the WELCOME-ACKED state where the "Welcome!" has been acknowledged.<p>
When a remote host connects to the application, the application sends the "Welcome!" message and sets it's state to WELCOME-SENT. When the welcome message is acknowledged, the application moves to the WELCOME-ACKED state. If the application receives any new data from the remote host, it responds by sending an "ok" back.<p>
If the application is requested to retransmit the last message, it looks at in which state the application is. If the application is in the WELCOME-SENT state, it sends a "Welcome!" message since it knows that the previous welcome message hasn't been acknowledged. If the application is in the WELCOME-ACKED state, it knows that the last message was an "ok" message and sends such a message.<p>
The implementation of this application is seen below. This configuration settings for the application is follows after its implementation.<p>
<div class="fragment"><pre><span class="keyword">struct </span>example2_state {
   <span class="keyword">enum</span> {WELCOME_SENT, WELCOME_ACKED} state;
};

<span class="keywordtype">void</span> example2_init(<span class="keywordtype">void</span>) {
   <a class="code" href="a00080.html#a25">uip_listen</a>(<a class="code" href="a00081.html#a2">HTONS</a>(2345));
}

<span class="keywordtype">void</span> example2_app(<span class="keywordtype">void</span>) {
   <span class="keyword">struct </span>example2_state *s;

   s = (<span class="keyword">struct </span>example2_state *)<a class="code" href="a00037.html">uip_conn</a>-&gt;appstate;
   
   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a15">uip_connected</a>()) {
      s-&gt;state = WELCOME_SENT;
      <a class="code" href="a00080.html#a5">uip_send</a>(<span class="stringliteral">"Welcome!\n"</span>, 9);
      <span class="keywordflow">return</span>;
   } 

   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a14">uip_acked</a>() &amp;&amp; s-&gt;state == WELCOME_SENT) {
      s-&gt;state = WELCOME_ACKED;
   }

   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a13">uip_newdata</a>()) {
      <a class="code" href="a00080.html#a5">uip_send</a>(<span class="stringliteral">"ok\n"</span>, 3);
   }

   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a19">uip_rexmit</a>()) {
      <span class="keywordflow">switch</span>(s-&gt;state) {
      <span class="keywordflow">case</span> WELCOME_SENT:
         <a class="code" href="a00080.html#a5">uip_send</a>(<span class="stringliteral">"Welcome!\n"</span>, 9);
         <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> WELCOME_ACKED:
         <a class="code" href="a00080.html#a5">uip_send</a>(<span class="stringliteral">"ok\n"</span>, 3);
         <span class="keywordflow">break</span>;
      }
   }
}
</pre></div><p>
The configuration for the application:<p>
<div class="fragment"><pre><span class="preprocessor">#define UIP_APPCALL       example2_app</span>
<span class="preprocessor">#define UIP_APPSTATE_SIZE sizeof(struct example2_state)</span>
</pre></div><h3><a name="example3"></a>
Differentiating between applications</h3>
If the system should run multiple applications, one technique to differentiate between them is to use the TCP port number of either the remote end or the local end of the connection. The example below shows how the two examples above can be combined into one application.<p>
<div class="fragment"><pre><span class="keywordtype">void</span> example3_init(<span class="keywordtype">void</span>) {
   example1_init();
   example2_init();   
}

<span class="keywordtype">void</span> example3_app(<span class="keywordtype">void</span>) {
   <span class="keywordflow">switch</span>(<a class="code" href="a00037.html">uip_conn</a>-&gt;lport) {
   <span class="keywordflow">case</span> <a class="code" href="a00081.html#a2">HTONS</a>(1234):
      example1_app();
      <span class="keywordflow">break</span>;
   <span class="keywordflow">case</span> <a class="code" href="a00081.html#a2">HTONS</a>(2345):
      example2_app();
      <span class="keywordflow">break</span>;
   }
}
</pre></div><h3><a name="example4"></a>
Utilizing TCP flow control</h3>
This example shows a simple application that connects to a host, sends an HTTP request for a file and downloads it to a slow device such a disk drive. This shows how to use the flow control functions of uIP.<p>
<div class="fragment"><pre><span class="keywordtype">void</span> example4_init(<span class="keywordtype">void</span>) {
   <a class="code" href="a00086.html#a1">u16_t</a> ipaddr[2];
   <a class="code" href="a00081.html#a1">uip_ipaddr</a>(ipaddr, 192,168,0,1);
   <a class="code" href="a00080.html#a2">uip_connect</a>(ipaddr, <a class="code" href="a00081.html#a2">HTONS</a>(80));
}

<span class="keywordtype">void</span> example4_app(<span class="keywordtype">void</span>) {
   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a15">uip_connected</a>() || <a class="code" href="a00080.html#a19">uip_rexmit</a>()) {
      <a class="code" href="a00080.html#a5">uip_send</a>(<span class="stringliteral">"GET /file HTTP/1.0\r\nServer:192.186.0.1\r\n\r\n"</span>,
               48);
      <span class="keywordflow">return</span>;
   }

   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a13">uip_newdata</a>()) {
      device_enqueue(uip_appdata, <a class="code" href="a00080.html#a6">uip_datalen</a>());
      <span class="keywordflow">if</span>(device_queue_full()) {
         <a class="code" href="a00080.html#a10">uip_stop</a>();
      }
   }

   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a20">uip_poll</a>() &amp;&amp; <a class="code" href="a00080.html#a11">uip_stopped</a>()) {
      <span class="keywordflow">if</span>(!device_queue_full()) {
         <a class="code" href="a00080.html#a12">uip_restart</a>();
      }
   }
}
</pre></div><p>
When the connection has been established, an HTTP request is sent to the server. Since this is the only data that is sent, the application knows that if it needs to retransmit any data, it is that request that should be retransmitted. It is therefore possible to combine these two events as is done in the example.<p>
When the application receives new data from the remote host, it sends this data to the device by using the function device_enqueue(). It is important to note that this example assumes that this function copies the data into its own buffers. The data in the uip_appdata buffer will be overwritten by the next incoming packet.<p>
If the device's queue is full, the application stops the data from the remote host by calling the uIP function <a class="el" href="a00080.html#a10">uip_stop()</a>. The application can then be sure that it will not receive any new data until <a class="el" href="a00080.html#a12">uip_restart()</a> is called. The application polling event is used to check if the device's queue is no longer full and if so, the data flow is restarted with <a class="el" href="a00080.html#a12">uip_restart()</a>.<h3><a name="example5"></a>
A simple web server</h3>
This example shows a very simple file server application that listens to two ports and uses the port number to determine which file to send. If the files are properly formatted, this simple application can be used as a web server with static pages. The implementation follows.<p>
<div class="fragment"><pre><span class="keyword">struct </span>example5_state {
   <span class="keywordtype">char</span> *dataptr;
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataleft;
};

<span class="keywordtype">void</span> example5_init(<span class="keywordtype">void</span>) {
   <a class="code" href="a00080.html#a25">uip_listen</a>(<a class="code" href="a00081.html#a2">HTONS</a>(80));
   <a class="code" href="a00080.html#a25">uip_listen</a>(<a class="code" href="a00081.html#a2">HTONS</a>(81));
}

<span class="keywordtype">void</span> example5_app(<span class="keywordtype">void</span>) {
   <span class="keyword">struct </span>example5_state *s;
   s = (<span class="keyword">struct </span>example5_state)uip_conn-&gt;appstate;
   
   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a15">uip_connected</a>()) {
      <span class="keywordflow">switch</span>(uip_conn-&gt;<a class="code" href="a00037.html#o1">lport</a>) {
      <span class="keywordflow">case</span> <a class="code" href="a00081.html#a2">HTONS</a>(80):
         s-&gt;dataptr = data_port_80;
         s-&gt;dataleft = datalen_port_80;
         <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> <a class="code" href="a00081.html#a2">HTONS</a>(81):
         s-&gt;dataptr = data_port_81;
         s-&gt;dataleft = datalen_port_81;
         <span class="keywordflow">break</span>;
      }
      <a class="code" href="a00080.html#a5">uip_send</a>(s-&gt;dataptr, s-&gt;dataleft);
      <span class="keywordflow">return</span>;      
   }

   <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a14">uip_acked</a>()) {
      <span class="keywordflow">if</span>(s-&gt;dataleft &lt; <a class="code" href="a00080.html#a22">uip_mss</a>()) {
         <a class="code" href="a00080.html#a8">uip_close</a>();
         <span class="keywordflow">return</span>;
      }
      s-&gt;dataptr += uip_conn-&gt;<a class="code" href="a00037.html#o5">len</a>;
      s-&gt;dataleft -= uip_conn-&gt;<a class="code" href="a00037.html#o5">len</a>;
      <a class="code" href="a00080.html#a5">uip_send</a>(s-&gt;dataptr, s-&gt;dataleft);      
   }
}
</pre></div><p>
The application state consists of a pointer to the data that should be sent and the size of the data that is left to send. When a remote host connects to the application, the local port number is used to determine which file to send. The first chunk of data is sent using <a class="el" href="a00080.html#a5">uip_send()</a>. uIP makes sure that no more than MSS bytes of data is actually sent, even though s-&gt;dataleft may be larger than the MSS.<p>
The application is driven by incoming acknowledgments. When data has been acknowledged, new data can be sent. If there is no more data to send, the connection is closed using <a class="el" href="a00080.html#a8">uip_close()</a>.<h3><a name="example6"></a>
Structured application program design</h3>
When writing larger programs using uIP it is useful to be able to utilize the uIP API in a structured way. The following example provides a structured design that has showed itself to be useful for writing larger protocol implementations than the previous examples showed here. The program is divided into an uIP event handler function that calls seven application handler functions that process new data, act on acknowledged data, send new data, deal with connection establishment or closure events and handle errors. The functions are called <a class="el" href="a00099.html#a11">newdata()</a>, <a class="el" href="a00097.html#a13">acked()</a>, <a class="el" href="a00097.html#a14">senddata()</a>, connected(), <a class="el" href="a00098.html#a5">closed()</a>, aborted(), and timedout(), and needs to be written specifically for the protocol that is being implemented.<p>
The uIP event handler function is shown below.<p>
<div class="fragment"><pre><span class="keywordtype">void</span> example6_app(<span class="keywordtype">void</span>) {
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a17">uip_aborted</a>()) {
    aborted();
  }
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a18">uip_timedout</a>()) {
    timedout();
  }
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a16">uip_closed</a>()) {
    closed();
  }
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a15">uip_connected</a>()) {
    connected();
  }
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a14">uip_acked</a>()) {
    acked();
  }
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a13">uip_newdata</a>()) {
    newdata();
  }
  <span class="keywordflow">if</span>(<a class="code" href="a00080.html#a19">uip_rexmit</a>() ||
     <a class="code" href="a00080.html#a13">uip_newdata</a>() ||
     <a class="code" href="a00080.html#a14">uip_acked</a>() ||
     <a class="code" href="a00080.html#a15">uip_connected</a>() ||
     <a class="code" href="a00080.html#a20">uip_poll</a>()) {
    senddata();
  }
}
</pre></div><p>
The function starts with dealing with any error conditions that might have happened by checking if <a class="el" href="a00080.html#a17">uip_aborted()</a> or <a class="el" href="a00080.html#a18">uip_timedout()</a> are true. If so, the appropriate error function is called. Also, if the connection has been closed, the <a class="el" href="a00098.html#a5">closed()</a> function is called to the it deal with the event.<p>
Next, the function checks if the connection has just been established by checking if <a class="el" href="a00080.html#a15">uip_connected()</a> is true. The connected() function is called and is supposed to do whatever needs to be done when the connection is established, such as intializing the application state for the connection. Since it may be the case that data should be sent out, the <a class="el" href="a00097.html#a14">senddata()</a> function is called to deal with the outgoing data.<p>
The following very simple application serves as an example of how the application handler functions might look. This application simply waits for any data to arrive on the connection, and responds to the data by sending out the message "Hello world!". To illustrate how to develop an application state machine, this message is sent in two parts, first the "Hello" part and then the "world!" part.<p>
<div class="fragment"><pre><span class="preprocessor">#define STATE_WAITING 0</span>
<span class="preprocessor"></span><span class="preprocessor">#define STATE_HELLO   1</span>
<span class="preprocessor"></span><span class="preprocessor">#define STATE_WORLD   2</span>
<span class="preprocessor"></span>
<span class="keyword">struct </span>example6_state {
  <a class="code" href="a00086.html#a0">u8_t</a> state;
  <span class="keywordtype">char</span> *textptr;
  <span class="keywordtype">int</span>  textlen;
};

<span class="keyword">static</span> <span class="keywordtype">void</span> aborted(<span class="keywordtype">void</span>) {}
<span class="keyword">static</span> <span class="keywordtype">void</span> timedout(<span class="keywordtype">void</span>) {}
<span class="keyword">static</span> <span class="keywordtype">void</span> closed(<span class="keywordtype">void</span>) {}

<span class="keyword">static</span> <span class="keywordtype">void</span> connected(<span class="keywordtype">void</span>) {
  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)uip_conn-&gt;<a class="code" href="a00037.html#o14">appstate</a>;

  s-&gt;state   = STATE_WAITING;
  s-&gt;textlen = 0;
}

<span class="keyword">static</span> <span class="keywordtype">void</span> newdata(<span class="keywordtype">void</span>) {
  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)uip_conn-&gt;<a class="code" href="a00037.html#o14">appstate</a>;

  <span class="keywordflow">if</span>(s-&gt;state == STATE_WAITING) {
    s-&gt;state   = STATE_HELLO;
    s-&gt;textptr = <span class="stringliteral">"Hello "</span>;
    s-&gt;textlen = 6;
  }
}

<span class="keyword">static</span> <span class="keywordtype">void</span> acked(<span class="keywordtype">void</span>) {
  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)uip_conn-&gt;<a class="code" href="a00037.html#o14">appstate</a>;
  
  s-&gt;textlen -= uip_conn-&gt;<a class="code" href="a00037.html#o5">len</a>;
  s-&gt;textptr += uip_conn-&gt;<a class="code" href="a00037.html#o5">len</a>;
  <span class="keywordflow">if</span>(s-&gt;textlen == 0) {
    <span class="keywordflow">switch</span>(s-&gt;state) {
    <span class="keywordflow">case</span> STATE_HELLO:
      s-&gt;state   = STATE_WORLD;
      s-&gt;textptr = <span class="stringliteral">"world!\n"</span>;
      s-&gt;textlen = 7;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> STATE_WORLD:
      <a class="code" href="a00080.html#a8">uip_close</a>();
      <span class="keywordflow">break</span>;
    }
  }
}

<span class="keyword">static</span> <span class="keywordtype">void</span> senddata(<span class="keywordtype">void</span>) {
  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)uip_conn-&gt;<a class="code" href="a00037.html#o14">appstate</a>;

  <span class="keywordflow">if</span>(s-&gt;textlen &gt; 0) {
    <a class="code" href="a00080.html#a5">uip_send</a>(s-&gt;textptr, s-&gt;textlen);
  }
}
</pre></div><p>
The application state consists of a "state" variable, a "textptr" pointer to a text message and the "textlen" length of the text message. The "state" variable can be either "STATE_WAITING", meaning that the application is waiting for data to arrive from the network, "STATE_HELLO", in which the application is sending the "Hello" part of the message, or "STATE_WORLD", in which the application is sending the "world!" message.<p>
The application does not handle errors or connection closing events, and therefore the aborted(), timedout() and <a class="el" href="a00098.html#a5">closed()</a> functions are implemented as empty functions.<p>
The connected() function will be called when a connection has been established, and in this case sets the "state" variable to be "STATE_WAITING" and the "textlen" variable to be zero, indicating that there is no message to be sent out.<p>
When new data arrives from the network, the <a class="el" href="a00099.html#a11">newdata()</a> function will be called by the event handler function. The <a class="el" href="a00099.html#a11">newdata()</a> function will check if the connection is in the "STATE_WAITING" state, and if so switches to the "STATE_HELLO" state and registers a 6 byte long "Hello " message with the connection. This message will later be sent out by the <a class="el" href="a00097.html#a14">senddata()</a> function.<p>
The <a class="el" href="a00097.html#a13">acked()</a> function is called whenever data that previously was sent has been acknowleged by the receiving host. This <a class="el" href="a00097.html#a13">acked()</a> function first reduces the amount of data that is left to send, by subtracting the length of the previously sent data (obtained from "uip_conn-&gt;len") from the "textlen" variable, and also adjusts the "textptr" pointer accordingly. It then checks if the "textlen" variable now is zero, which indicates that all data now has been successfully received, and if so changes application state. If the application was in the "STATE_HELLO" state, it switches state to "STATE_WORLD" and sets up a 7 byte "world!\n" message to be sent. If the application was in the "STATE_WORLD" state, it closes the connection.<p>
Finally, the <a class="el" href="a00097.html#a14">senddata()</a> function takes care of actually sending the data that is to be sent. It is called by the event handler function when new data has been received, when data has been acknowledged, when a new connection has been established, when the connection is polled because of inactivity, or when a retransmission should be made. The purpose of the <a class="el" href="a00097.html#a14">senddata()</a> function is to optionally format the data that is to be sent, and to call the <a class="el" href="a00080.html#a5">uip_send()</a> function to actually send out the data. In this particular example, the function simply calls <a class="el" href="a00080.html#a5">uip_send()</a> with the appropriate arguments if data is to be sent, after checking if data should be sent out or not as indicated by the "textlen" variable.<p>
It is important to note that the <a class="el" href="a00097.html#a14">senddata()</a> function never should affect the application state; this should only be done in the <a class="el" href="a00097.html#a13">acked()</a> and <a class="el" href="a00099.html#a11">newdata()</a> functions. <hr size="1"><address style="align: right;"><small>Generated on Tue Oct 7 15:51:00 2003 for uIP 0.9 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.3 </small></address>
</body>
</html>
